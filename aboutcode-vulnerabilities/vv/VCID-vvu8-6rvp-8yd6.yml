vulnerability_id: VCID-vvu8-6rvp-8yd6
aliases:
  - CVE-2023-54271
summary: "In the Linux kernel, the following vulnerability has been resolved:  blk-cgroup: Fix\
  \ NULL deref caused by blkg_policy_data being installed before init  blk-iocost sometimes\
  \ causes the following crash:    BUG: kernel NULL pointer dereference, address: 00000000000000e0\
  \   ...   RIP: 0010:_raw_spin_lock+0x17/0x30   Code: be 01 02 00 00 e8 79 38 39 ff 31 d2 89\
  \ d0 5d c3 0f 1f 00 0f 1f 44 00 00 55 48 89 e5 65 ff 05 48 d0 34 7e b9 01 00 00 00 31 c0 <f0>\
  \ 0f b1 0f 75 02 5d c3 89 c6 e8 ea 04 00 00 5d c3 0f 1f 84 00 00   RSP: 0018:ffffc900023b3d40\
  \ EFLAGS: 00010046   RAX: 0000000000000000 RBX: 00000000000000e0 RCX: 0000000000000001   RDX:\
  \ ffffc900023b3d20 RSI: ffffc900023b3cf0 RDI: 00000000000000e0   RBP: ffffc900023b3d40 R08:\
  \ ffffc900023b3c10 R09: 0000000000000003   R10: 0000000000000064 R11: 000000000000000a R12:\
  \ ffff888102337000   R13: fffffffffffffff2 R14: ffff88810af408c8 R15: ffff8881070c3600   FS:\
  \  00007faaaf364fc0(0000) GS:ffff88842fdc0000(0000) knlGS:0000000000000000   CS:  0010 DS:\
  \ 0000 ES: 0000 CR0: 0000000080050033   CR2: 00000000000000e0 CR3: 00000001097b1000 CR4: 0000000000350ea0\
  \   Call Trace:    <TASK>    ioc_weight_write+0x13d/0x410    cgroup_file_write+0x7a/0x130\
  \    kernfs_fop_write_iter+0xf5/0x170    vfs_write+0x298/0x370    ksys_write+0x5f/0xb0   \
  \ __x64_sys_write+0x1b/0x20    do_syscall_64+0x3d/0x80    entry_SYSCALL_64_after_hwframe+0x46/0xb0\
  \  This happens because iocg->ioc is NULL. The field is initialized by ioc_pd_init() and never\
  \ cleared. The NULL deref is caused by blkcg_activate_policy() installing blkg_policy_data\
  \ before initializing it.  blkcg_activate_policy() was doing the following:  1. Allocate pd's\
  \ for all existing blkg's and install them in blkg->pd[]. 2. Initialize all pd's. 3. Online\
  \ all pd's.  blkcg_activate_policy() only grabs the queue_lock and may release and re-acquire\
  \ the lock as allocation may need to sleep. ioc_weight_write() grabs blkcg->lock and iterates\
  \ all its blkg's. The two can race and if ioc_weight_write() runs during #1 or between #1\
  \ and #2, it can encounter a pd which is not initialized yet, leading to crash.  The crash\
  \ can be reproduced with the following script:    #!/bin/bash    echo +io > /sys/fs/cgroup/cgroup.subtree_control\
  \   systemd-run --unit touch-sda --scope dd if=/dev/sda of=/dev/null bs=1M count=1 iflag=direct\
  \   echo 100 > /sys/fs/cgroup/system.slice/io.weight   bash -c \"echo '8:0 enable=1' > /sys/fs/cgroup/io.cost.qos\"\
  \ &   sleep .2   echo 100 > /sys/fs/cgroup/system.slice/io.weight  with the following patch\
  \ applied:  > diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c > index fc49be622e05..38d671d5e10c\
  \ 100644 > --- a/block/blk-cgroup.c > +++ b/block/blk-cgroup.c > @@ -1553,6 +1553,12 @@ int\
  \ blkcg_activate_policy(struct gendisk *disk, const struct blkcg_policy *pol) > \t\tpd->online\
  \ = false; > \t} > > +       if (system_state == SYSTEM_RUNNING) { > +               spin_unlock_irq(&q->queue_lock);\
  \ > +               ssleep(1); > +               spin_lock_irq(&q->queue_lock); > +      \
  \ } > + > \t/* all allocated, init in the same order */ > \tif (pol->pd_init_fn) > \t\tlist_for_each_entry_reverse(blkg,\
  \ &q->blkg_list, q_node)  I don't see a reason why all pd's should be allocated, initialized\
  \ and onlined together. The only ordering requirement is that parent blkgs to be initialized\
  \ and onlined before children, which is guaranteed from the walking order. Let's fix the bug\
  \ by allocating, initializing and onlining pd for each blkg and holding blkcg->lock over initialization\
  \ and onlining. This ensures that an installed blkg is always fully initialized and onlined\
  \ removing the the race window."
severities:
  - score: '5.5'
    scoring_system: cvssv3
    scoring_elements: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
    published_at: None
    url: https://access.redhat.com/hydra/rest/securitydata/cve/CVE-2023-54271.json
  - score: '0.00022'
    scoring_system: epss
    scoring_elements: '0.0513'
    published_at: '2026-01-08 12:55:00+00:00'
    url: https://api.first.org/data/v1/epss?cve=CVE-2023-54271
  - score: '0.00022'
    scoring_system: epss
    scoring_elements: '0.05111'
    published_at: '2026-01-11 12:55:00+00:00'
    url: https://api.first.org/data/v1/epss?cve=CVE-2023-54271
  - score: '4.1'
    scoring_system: cvssv3.1
    scoring_elements: CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:H
    published_at: None
    url: https://ftp.suse.com/pub/projects/security/yaml/suse-cvss-scores.yaml
weaknesses:
  - CWE-476
references:
  - url: https://access.redhat.com/hydra/rest/securitydata/cve/CVE-2023-54271.json
    reference_type:
    reference_id:
  - url: https://api.first.org/data/v1/epss?cve=CVE-2023-54271
    reference_type:
    reference_id:
  - url: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-54271
    reference_type:
    reference_id:
  - url: https://ftp.suse.com/pub/projects/security/yaml/suse-cvss-scores.yaml
    reference_type:
    reference_id:
  - url: https://bugzilla.redhat.com/show_bug.cgi?id=2426240
    reference_type:
    reference_id: 2426240
  - url: https://access.redhat.com/errata/RHSA-2024:9315
    reference_type:
    reference_id: RHSA-2024:9315
